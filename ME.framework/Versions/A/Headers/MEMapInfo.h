//  Copyright (c) 2012 BA3, LLC. All rights reserved.
#import <Foundation/Foundation.h>
#import "MEProtocols.h"
#import "METileInfo.h"

//////////////////////////////////////////////////
//Forward declarations
@class MEMapViewController;
@class METileProvider;

//////////////////////////////////////////////////
/**Enumeration of different map types.*/
typedef enum {
	kMapTypeUnknown,
    kMapTypeFileTerrain,
	kMapTypeFileTerrainTAWS,
	kMapTypeFileRaster,
	kMapTypeFileRasterPVR,
	kMapTypeFileRasterPVR_RAW,
    kMapTypeVirtualRaster,
	kMapTypeVirtualRasterAnimated,
	kMapTypeFileVector,
	kMapTypeDynamicVector,
    kMapTypeFileMarker,
	kMapTypeFileMarkerCreate,
	kMapTypeMemoryMarker,
	kMapTypeMemoryMarkerFast,
	kMapTypeDynamicMarker,
	kMapTypeDynamicMarkerFast,
	kMapTypeFileMBTiles,
	kMapTypeVirtualVector
} MEMapType;

//////////////////////////////////////////////////
/**Enumeration of different map content types.*/
typedef enum {
	kZoomDependent,
	kZoomIndependent
} MEMapContentType;

//////////////////////////////////////////////////
/**Enumeration of different map loading strategies.*/
typedef enum {
	kLowestDetailFirst,
	kHighestDetailOnly
} MEMapLoadingStrategy;


/////////////////////////////////////////////////////////////
/**Enumeration of different marker map loading strategies.*/
typedef enum {
	kMarkerImageLoadingAsynchronous,
	kMarkerImageLoadingSynchronous,
	kMarkerImageLoadingPrecached
} MEMarkerImageLoadingStrategy;

//////////////////////////////////////////////////
/**Describes the file and table prefixes associated with a map.
 Serves as base class for specific map info objects.
 */
@interface MEMapFileInfo : NSObject

/**Physical path of index sqlite file for the map.*/
@property (retain) NSString* sqliteFileName;

/**Table name prefix in cases where sqlite file contains data for multiple maps.*/
@property (retain) NSString* tableNamePrefix;

/**Physical path of data file for the map.*/
@property (retain) NSString* dataFileName;

@end

//////////////////////////////////////////////////
/**Describes a map layer and options for it. Used when adding a map or inquiring about map. There are several sub-classes of MEMapInfo. When adding a map, you create an MEMapInfo object of the appropriate type, populate its properties and then call MEMapViewController addMapUsingMapInfo passing in the MEMapInfo object.
 
 There are several possible map types:
 
 - kMapTypeUnknown: Default. Will result in a warning if you have verbose messages enabled.
 - kMapTypeFileTerrain: Disk-based terrain map generated by metool.
 - kMapTypeFileTerrainTAWS: Disk-based terrain map drawn with a terrain proximity color-bar.
 - kMapTypeFileRaster: Disk-based raster map generated by metool.
 - kMapTypeFileRasterPVR: Disk-based raster map comprised of PVR-compressed textures with headers, generated by metool.
 - kMapTypeFileRasterPVR_RAW: Disk-based raster map comprised of PVR-compressed textures without headers, generated by metool.
 - kMapTypeVirtualRaster: A map in which data will be supplied by an METileProvider-derived object.
 - kMapTypeVirtualRasterAnimated: A multi-frame animated map in which data will be supplied by an METileProvider-derived object.
 - kMapTypeFileVector: Disk-based vector map generated by metool.
 - kMapTypeDynamicVector: In-memory vector map in which lines, polygons, and vector markers are dynamically added or removed.
 - kMapTypeFileMarker: Disk-based marker map generated by metool.
 - kMapTypeFileMarkerCreate: Instructs the mapping engine to create and write out a clustered marker map with the supplied markers.
 - kMapTypeMemoryMarker: In-memory clustered marker map. Added using an array of MEMarkerAnnotation objects. Marker images will be requested as needed from the delegate.
 - kMapTypeMemoryMarkerFast: In-memory clustered marker map. Added using an array of MEFastMarkerInfo objects. Images must be pre-cached.
 - kMapTypeDynamicMarker: In-memory dynamic marker map to which markers can be added and later have their positions updated. Marker images will be requested as needed from the delegate.
 - kMapTypeDynamicMarkerFast: In-memory dynamic marker map to which markers can be added and later have their positions updated. Marker images must be pre-cached.
 - kMapTypeFileMBTiles: Disk-based mbtiles map generated with the MapBox TileMill program.
 
 When adding a map you must select the appropriate MEMapInfo object type.
 
 - MEMapInfo: Terrain and raster maps generated with metool.
 - MEMBTilesMapInfo: MapBox mbtiles file.
 - MEMarkerMapInfo: Any marker map type.
 - MEVectorMapInfo: Any vector map type.
 - MEVirtualMapInfo: Non-animated maps for which you will provide the data via an METileProvider-derived object.
 - MEAnimatedVirtualMapInfo: Animated maps for which you will provide the data via an METileProvider-derived object.
 
 Different maps can have different content types and loading strategies.
 
 Content types meanings:
 
 - kZoomDependent: The map is comprised of different imagery at different zoom levels. This would apply to almost all internet-based street maps where the level of detail of the data increases as you zoom in. This would not apply to most aerial or satellite image. When using content of this type, you will might want to set tileLevelBiasing to 1.0 which will force tiles to always be of the same level (at a memory cost).
 - kZoomIndependent: The map is created by sampling a large fixed raster data set (satellite images, scanned FAA sectionals, aerial photographs, etc.).
 
 Controlling loading strategies:
 
 - kLowestDetailFirst: The currently viewed area of the map is loaded from the lowest detail to the highest. This costs more in terms of loading time but if maps are local, can result in a smoother feel when zooming and panning.
 - kHighestDetailOnly: Only the detail level currently in view is loaded. Generally faster for internet-based virtual maps.
 
 For marker maps:
 
 - kMarkerImageLoadingAsynchronous: Marker map delegate will receive requests for images, as-needed, on a background thread. Good for when you have hundreds of thousands of markers and loading speed is not super important.
 - kMarkerImageLoadingSynchronous: Marker map delegate will receive requests for iamges, as-needed, on the primary thread. Good for when you have hundreds of markers and loading speed is important.
 - kMarkerImageLoadingPrecached: Marker images are pre-cached with the mapping engine. There is no separate loading step. This is good for limited use when you need the fastest possible display. 
 
 */
@interface MEMapInfo : MEMapFileInfo

/**Map type.*/
@property (assign) MEMapType mapType;

/**Map loading strategy type.*/
@property (assign) MEMapLoadingStrategy mapLoadingStrategy;

/**Unique name of map.*/
@property (retain) NSString* name;

/**The view controller that is managing this map.*/
@property (retain) MEMapViewController* meMapViewController;

/**They layer order of this map, higher means higher in the stack.*/
@property (assign) unsigned int zOrder;

/**Maximum detail level of the map. (Specified for in-memory marker maps and virtual maps).*/
@property (assign) unsigned int maxLevel;

/**0 to 1 value for the map alpha. 0 is invisible, 1 is opaque.*/
@property (assign) double alpha;

/**Whether or not the map is vibile.*/
@property (assign) BOOL isVisible;

/**Whether or not to compress textures for this map to 2 byte formats.*/
@property (assign) BOOL compressTextures;

/**The minimum longitude for this map.*/
@property (assign) double minX;

/**The minimum latitude for this map.*/
@property (assign) double minY;

/**The maximum longitude for this map.*/
@property (assign) double maxX;

/**The maximum latitude for this map.*/
@property (assign) double maxY;

/**Specifies number of pixels that border each tile.*/
@property (assign) unsigned int borderPixelCount;

/**Specifies the name of the pre-loaded default tile to render while tiles are being loaded or to use when a tile is not available. */
@property (retain) NSString* defaultTileName;

@end

//////////////////////////////////////////////////
/**Describes an MBTiles map.*/
@interface MEMBTilesMapInfo : MEMapInfo

/**The type of image tiles in the map.*/
@property (assign) MEImageDataType imageDataType;

@end

////////////////////////////////////////////////////////////////////////
/**Describes a dynamic marker map. Use dynamic marker maps when you need to frequently update a marker image, rotation, and/or position.
 */
@interface MEDynamicMarkerMapInfo : MEMapInfo

/**Delegate to receive hit testing notifications.*/
@property (retain) id<MEDynamicMarkerMapDelegate> meDynamicMarkerMapDelegate;

/**Controls whether the engine performs touch-point hit testing against the markers. Defaults to YES.*/
@property (assign) BOOL hitTestingEnabled;

/**Specifies whether markers fade in.*/
@property (assign) BOOL fadeEnabled;

/**Amount of time in seconds that markers fade in.*/
@property (assign) double fadeInTime;

/**Amount of time in seconds that markers fade out.*/
@property (assign) double fadeOutTime;

@end

//////////////////////////////////////////////////
/**Describes a marker map.*/
@interface MEMarkerMapInfo : MEMapInfo

/**For marker maps, the marker map delegate that will provide marker images.*/
@property (retain) id<MEMarkerMapDelegate> meMarkerMapDelegate;

/**For marker maps, the array of markers to add.*/
@property (retain) NSArray* markers;

/**Cluster distance to use for markers.*/
@property (assign) CGFloat clusterDistance;

/**Controls how the engine requests marker images. Defaults to kAsynchronousMarkerImageLoading. Note: frame hitching can occur if you use kMarkerImageLoadingAsynchronous for a large set of markers. Use asynchronous loading when possible.*/
@property (assign) MEMarkerImageLoadingStrategy markerImageLoadingStrategy;

/**Controls whether the engine performs touch-point hit testing against the markers. Defaults to YES.*/
@property (assign) BOOL hitTestingEnabled;

/**Specifies whether markers fade in.*/
@property (assign) BOOL fadeEnabled;

/**Amount of time in seconds that markers fade in.*/
@property (assign) double fadeInTime;

/**Amount of time in seconds that markers fade out.*/
@property (assign) double fadeOutTime;

@end

/**Describes a vector map.*/
@interface MEVectorMapInfo : MEMapInfo

/**Optional delegate that will receive touch events on dynamic vector geometry objects.*/
@property (retain) id<MEVectorMapDelegate> meVectorMapDelegate;

@end

//////////////////////////////////////////////////
/**Describes a virtual map.*/
@interface MEVirtualMapInfo : MEMapInfo

/**Tile provider that will serve up tiles for this virtual map.*/
@property (retain) METileProvider* meTileProvider;

/**Specifies map content type.*/
@property (assign) MEMapContentType contentType;

/**Specifies map loading strategy.*/
@property (assign) MEMapLoadingStrategy loadingStrategy;

/**Specifies that the tile source is spherical mercator (Google / Slippy style) tiles.*/
@property (assign) BOOL isSphericalMercator;

@end

//////////////////////////////////////////////////
/**Describes an animated virtual map.*/
@interface MEAnimatedVirtualMapInfo : MEVirtualMapInfo

/**Specifies number of frames.*/
@property (assign) unsigned int frameCount;

/**Specifies number of frames to play per second.*/
@property (assign) CGFloat frameRate;

/**Specifies the number of seconds to wait before repeating the animation.*/
@property (assign) CGFloat repeatDelay;

/**Specifies whether to apply an inter-frame fade.*/
@property (assign) BOOL fadeEnabled;

/**Specifies whether or not the mapping engine will automatically request tiles for the map. If set to NO, you can force tiles to be requested for the current view using MEMapViewController politelyRefreshAnimatedMap.*/
@property (assign) BOOL automaticTileRequestMode;

@end







